<!DOCTYPE html>
<html>
<head>
<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/loaders/GLTFLoader.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/jsm/renderers/CSS2DRenderer.min.js"></script>
 <!-- Add this to your HTML file -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

  </head> 
 <body> 
   
<!--     mettre en place un panneu d'affichage Html pour les comments  -->
 <div id="info-container"></div>
    
    <script>
const scene = new THREE.Scene();
scene.background = null;

const renderer = new THREE.WebGLRenderer({ alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 4, 15);
const target = new THREE.Vector3(0, 0, 0);

const gltfLoader = new THREE.GLTFLoader();
gltfLoader.load('https://cdn.glitch.global/9b657b83-cc2c-4197-a38a-10818ce55be0/toiletHotspot.glb?v=1663760953490', (gltf) => {
  // Set up the materials in the model
  gltf.scene.traverse((object) => {
    if (object.isMesh) {
      object.material.color.set("lightblue");
    }
    });

  // Set position, scale, and rotation for the model
 // const toiletModel = gltf.scene.children[0];
 gltf.scene.children[0].scale.set(.18,.18,.18);
   gltf.scene.children[0].position.set(7,0,0);
  gltf.scene.children[0].rotateY(THREE.Math.degToRad(-180));

  scene.add(gltf.scene.children[0]);
  
  // defining initial colors and textures

const miroir = scene.getObjectByName("mesh_3");
miroir.name = "miroir";
//console.log(miroir);
miroir.material.color.set("white");
//miroir.material.metalness = 0.3;
  
// //  Create a material with a webcam texture
// const videoWebcam = document.createElement('video');
// videoWebcam.autoplay = true;
// navigator.mediaDevices
//   .getUserMedia({ video: true })
//   .then(function (stream) {
//     videoWebcam.srcObject = stream;
//   })
//   .catch(function (error) {
//     console.error('Error accessing the webcam:', error);
//   });
//  const textureWebcam = new THREE.VideoTexture(videoWebcam);
// miroir.material.map = textureWebcam;
  
  
const sanitaire = scene.getObjectByName("mesh_4");
sanitaire.name = "sanitaire";
//console.log(sanitaire);
sanitaire.material.color.set("white");
// mesh.material.needsUpdate = true;
const lavabo = scene.getObjectByName("mesh_0");
lavabo.name = "lavabo";
//console.log(lavabo);
lavabo.material.color = new THREE.Color(0xffffff);
//lavabo.material.metalness = 0.1;
//lavabo.material.roughness = 1;
// mesh.material.needsUpdate = true;
const mur = scene.getObjectByName("mesh_6");
mur.name = "mur";
//console.log(mur);
mur.material.color.set("0xcccccc");
mur.material.transparent = true;
mur.material.opacity = 0.5;
const sol = scene.getObjectByName("mesh_2");
sol.name = "sol";
//console.log(sol);
sol.material.color.set("black");
sol.material.transparent = true;
sol.material.opacity = 0.1;

const corbeille = scene.getObjectByName("mesh_15");
corbeille.name = "corbeille";
corbeille.material.color.set("lightgreen");
// corbeille.material.transparent = true;
// corbeille.material.opacity = 0;
corbeille.scale.set(0.8, 3, 0.8);
corbeille.translateY(9);
corbeille.translateX(-5);

const conso = scene.getObjectByName("mesh_11");
conso.name = "conso";
conso.material.color.set("pink");

  // Set up lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, .4);
  directionalLight.position.set(10,4, 10);
  scene.add(directionalLight);
  
        
  // create control
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.update();

  animate();
});

// Add raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Event listeners
        
    function isMobile() {
  return /Mobi/i.test(navigator.userAgent);
}
    
    function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
}

//if (isMobile()) {
    
    if (isTouchDevice()){
  window.addEventListener('touchstart', onTouchStart, false);
} else {
  window.addEventListener('mousemove', onMouseMove, false);
  window.addEventListener('click', onClick, false);
}

function onMouseMove(event) {
  updateMousePosition(event);
 
  raycaster.setFromCamera(mouse, camera);
}

function onTouchStart(event) {
   isToggleFunctionRunning = false; // arreter le clignotement
 event.preventDefault();
  

  const touch = event.touches[0];
  const x = (touch.clientX / window.innerWidth) * 2 - 1;
  const y = -(touch.clientY / window.innerHeight) * 2 + 1;
  
  updateMousePosition(touch); 
  raycaster.setFromCamera(mouse, camera);
  handleIntersections();
}

function updateMousePosition(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

function onClick(event) {
  
  raycaster.setFromCamera(mouse, camera);
  handleIntersections();
}

function handleIntersections() {
 
  const intersects = raycaster.intersectObjects(scene.children, true);

  //if (intersects.length > 0) {
  let mesh = null ;
     for (const hit of intersects) {
    if (hit.object?.name?.includes('sphere')) {
      mesh = hit.object;
      break;
    }
  }

if(mesh){
   const name = mesh.name;
   const index = parseInt(name.substr(name.length - 1)) ;
     console.log("Sphère cliquée :",name);
   const prompt = `Le stagiaire a cliqué sur le point ${index}. Pose-lui une question pédagogique sur cette zone de nettoyage.`;
// traitement visuel d'abord  
for (let j = 0; j < names.length; j++) {
    
        if (j === index) {
          sphereNumeros[j].material.opacity  = .1;
          videoSprites[j].visible = true;
          comments[j].visible = true;
          videos[j].play();
          titleSprites[j].visible = true;
          updateCameraPositionAndTarget(mesh.position);
        } else {
            videoSprites[j].visible = false;
          comments[j].visible = false;
          videos[j].pause();
          titleSprites[j].visible = false;
           sphereNumeros[j].material.opacity  = .7;
        }
      }


 lancerExerciceDialogue();
//callBot(index);

} else{
      console.log("No  sphere object found intersectsObject.");
    }
   isToggleFunctionRunning = true;
  }

  function updateMousePosition(event) {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
       // visibilité des elements image 2
           
              for (let j = 0; j < titleSecures.length; j++) { 
                
                // console.log(camera.position.z);
                   if(camera.position.z<5){
                     
                     console.log(camera.position.z)
            titleSecures[j].visible = true;
           
        //titlePlanes2[j].visible = false
          }
           else{ titleSecures[j].visible = false;
            //titlePlanes2[j].visible = true
               }     
          }     
  
       for (let j = 0; j < sphereNumeros.length; j++) { 
         //   var isToggleFunctionRunning = false;
                   if(camera.position.z>10){        
            sphereNumeros[j].visible = true;
          // titleSprites[j].visible = true
          }
           else{ sphereNumeros[j].visible =false;
                //titleSprites[j].visible = false
               }     
              
       }
}


function updateCameraPositionAndTarget(targetPosition) {
 const cameraOffsetX = 5;
  const cameraOffsetZ = 5;
  const cameraPosition = targetPosition.clone().add(new THREE.Vector3(cameraOffsetX, 0, cameraOffsetZ));
  gsap.to(camera.position, {
    x: cameraPosition.x,
    y: cameraPosition.y + 1,
    z: cameraPosition.z,
    duration: 2,
    ease: "power2.out"
  });
  controls.target.copy(targetPosition);
  camera.up.set(0, 5, 0);
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
 </script>
   <script src = "buildScene.js"></script>
   <script src = "securite.js"></script>
   <script src = "gptChat.js"></script>
</body>
</html>
